# In this file, we'll define a non-commutative Frobenius algebra and prove some
# standard facts.


# First, introduce generators for multiplication (m), unit (u), comultiplication (n),
# and counit (v).
gen m : 2 -> 1
gen u : 0 -> 1
gen n : 1 -> 2
gen v : 1 -> 0

# (m, u) forms a monoid
rule assoc : m * id ; m = id * m ; m
rule unitL : u * id ; m = id
rule unitR : id * u ; m = id

# (n, v) forms a comonoid
rule coassoc : n ; n * id = n ; id * n
rule counitL : n ; v * id = id
rule counitR : n ; id * v = id

# there are many equivalent formulations of the Frobenius condition. Here's one:
rule frob : n * id ; id * m = id * n ; m * id

# The rule above is equivalent to the slightly more familiar pair of rules:
#
#   frobL : n * id ; id * m = m ; n
#   frobR : id * n ; m * id = m ; n
#
# If m and n were both commutative, one of these would imply the other, and either
# would imply "frob". However, for non-commutative Frobenius algebras, we need them
# both.

# Let's prove these both follow from "frob". Once we prove one...
rewrite frobL :
  n * id ; id * m
  = u * n * id ; m * m by -unitL
  = u * id * id ; n * id * id ; id * m * id ; id * m by -frob
  = u * m ; n * id ; id * m by assoc
  = u * m ; id * n ; m * id by frob
  = m ; n by unitL

# ...the other is easy:
rewrite frobR :
  id * n ; m * id
  = n * id ; id * m by -frob
  = m ; n by frobL

# Going back the other way, we have:
rewrite frob_again:
  n * id ; id * m
  = m ; n by frobL
  = id * n ; m * id by -frobR


# Frobenis algebras always induce a "cup" and "cap" map:
let cup = u ; n
let cap = m ; v

# By definition, "cap" satisfies and associativity condition with m:
rewrite cap_assoc :
  m * id ; cap
  = id * m ; cap by assoc

# ...and "cup" a coassociativity condition with n:
rewrite cup_coassoc :
  cup ; n * id
  = cup ; id * n by coassoc


# Thanks to frobL and frobR, we can prove the following "yanking" equations:
#
#   yankL : cup * id ; id * cap = id
#   yankR : id * cup ; cap * id = id
#
rewrite yankL :
  cup * id ; id * cap
  = u * id ; m ; n ; id * v by frobL
  = n ; id * v by unitL
  = id by counitR

rewrite yankR :
  id * cup ; cap * id
  = u * id ; sw ; m ; n ; v * id by frobR
  = n ; v * id by unitR
  = id by counitL


# We can also prove the cups can transform multiplications into comultiplications:
#
#  m_cupL : cup * id ; id * m = n
#  m_cupR : id * cup ; m * id = n
#

rewrite m_cupL :
  cup * id ; id * m
  = u * n ; m * id by frob
  = n by unitL

rewrite m_cupR :
  id * cup ; m * id
  = n * u ; id * m by -frob
  = n by unitR



# As a final exercise, let's show that the tensor product of a Frobenius algebra
# with itself is also a Frobenius algebra. That is, for:

let m2 = id * sw * id ; m * m
let u2 = u * u
let n2 = n * n ; id * sw * id
let v2 = v * v

# ...we can prove all of the Frobenius rules.

# For convenience in stating the rules, we also define:
let id2 = id * id

# Note how definitions are unfolded automatically. In each of the proofs below, we introduce
# a trivial final step to fold the definitions back up.

# (m2, u2) forms a monoid
rewrite assoc2 :
  m2 * id2 ; m2
  = id * id * sw * id * id ; id * m * m * id ; id * sw * id ; m * m by assoc
  = id * id * id * sw * id ; id * id * m * m ; id * sw * id ; m * m by assoc
  = id2 * m2 ; m2

rewrite unitL2 :
  u2 * id2 ; m2
  = u * id * id ; m * id by unitL
  = id * id by unitL
  = id2

rewrite unitR2 :
  id2 * u2 ; m2
  = u * id * id ; sw * id ; m * id by unitR
  = id * id by unitR
  = id2

# (n2, v2) forms a comonoid
rewrite coassoc2 :
  n2 ; n2 * id2
  = n * n ; n * id * id * n ; id * sw[2, 0, 3, 1] * id by coassoc
  = n * n ; id * n * id * n ; id * sw[2, 0, 3, 1] * id by coassoc
  = n2 ; id2 * n2

rewrite counitL2 :
  n2 ; v2 * id2
  = n * id ; v * id * id by counitL
  = id * id by counitL
  = id2

rewrite counitR2 :
  n2 ; id2 * v2
  = n * id ; id * v * id by counitR
  = id * id by counitR
  = id2
  

# and last but not least, the Frobenius equation:
rewrite frob2 :
  n2 * id2 ; id2 * m2
  = n * id * id * n ; id * id * sw * id * id ; id * m * m * id ; id * sw * id by frob
  = id * id * n * n ; id * sw * sw * id ; m * m * id * id by frob
  = id2 * n2 ; m2 * id2


# Generic non-commutative Frobenius algebras are a bit wild, so we often look at special symmetric
# Frobenius algebras (SSFAs). These satisfy two extra conditions:
#
#   spec : n ; m = id
#   symm : sw ; cap = cap
#
# In fact, both of these rules are implied by a single rule, relating the "Killing form" to the
# counit.

# The Killing form is the (left) partial trace of the multiplication, which we can define as
# follows:
let kf = cup * id ; id * m ; sw ; cap

# In fact, it doesn't matter if we take the left or right partial trace, since the m_cup rules
# let us flip between the two:
rewrite kf_flip :
  kf
  = n ; sw ; cap by m_cupL
  = id * cup ; m * id ; sw; cap by -m_cupR


# Now, we can show that a Frobenius algebra is an SSFA if and only if the Killing form equals
# the counit:

rule ssym : kf = v


# First, we prove symmetry. This one is a bit tricky to follow. The main thing to note is the two
# steps "-yankR" and "yankR" are essentially invoking cyclicity of the partial trace.
rewrite symm :
  cap
  = u * m ; n * id ; id * m ; sw ; m ; v by -ssym
  = u * id * id ; n * id * id ; id * m * id ; id * m ; sw ; m ; v by -assoc
  = u * id * u * id ; n * id * n * id ; id * m * id * m ; sw[1, 2, 3, 0] ; m * m ; v * v by -yankR
  = u * id * id ; n * id * id ; id * id * sw ; id * m * id ; id * m ; sw ; m ; v by yankR
  = sw ; u * m ; n * id ; id * m ; sw ; m ; v by assoc
  = sw ; m ; v by ssym

# Next, we prove specialness. We start with a lemma relating the Killing form to the LHS of
# the "spec" rule:
rewrite spec_lem :
  n ; id * kf
  = n ; id * n ; id * sw ; id * cap by m_cupL
  = n ; n * id ; id * sw ; id * m ; id * v by -coassoc
  = n ; n * id ; id * m ; id * v by symm
  = n ; id * n ; m * v by frob
  = n ; m by counitR

# Combining ssym with the counit rule completes the proof:
rewrite spec :
  n ; m
  = n ; id * kf by -spec_lem
  = n ; id * v by ssym
  = id by counitR


# Going back the other way, we have:
rewrite ssym_again :
  kf
  = u * id ; n * id ; id * m ; sw ; m ; v
  = u * id ; n * id ; id * m ; m ; v by symm
  = u * id ; m ; n ; m ; v by frobL
  = u * id ; m ; v by spec
  = v by unitL

