# In this file, we'll develop the theory of modules of a quasi-triangular Hopf algebra

# First, we'll import the Hopf algebra, and keep its rules in a namespace H
gen m : 2 -> 1
gen u : 0 -> 1
gen n : 1 -> 2
gen v : 1 -> 0
gen s : 1 -> 1
gen r : 0 -> 2
gen rL : 2 -> 2
import quasi_tri as H(m=m, u=u, n=n, v=v, s=s, r=r, rL=rL)

# Now, we'll create three modules, called A, B, and C. Note that chyp is currently
# single-sorted, so these are all different modules over the same underlying space
gen a : 2 -> 1
gen b : 2 -> 1
gen c : 2 -> 1
import module as A(m=m, u=u, a=a)
import module as B(m=m, u=u, a=b)
import module as C(m=m, u=u, a=c)

# For convenience, we'll define the action of the Hopf algebras R-matrix on
# all pairs of modules, which induces a braiding map between those two modules
def rL_ab = r * id * id ; id * sw * id ; a * b
let br_ab = sw ; rL_ab
def rL_bc = r * id * id ; id * sw * id ; b * c
let br_bc = sw ; rL_bc
def rL_ac = r * id * id ; id * sw * id ; a * c
let br_ac = sw ; rL_ac

# Associativity let's us "push" the adjoint action of the R-matrix through any
# pair of modules, giving the following commutativity laws:
rewrite rL_ab_comm :
  rL * id * id ; id * sw * id ; a * b
  = id * sw * id ; a * b ; rL_ab by simp(H.rL_unfold, A.assoc, B.assoc, rL_ab_def)

rewrite rL_bc_comm :
  rL * id * id ; id * sw * id ; b * c
  = id * sw * id ; b * c ; rL_bc by simp(H.rL_unfold, B.assoc, C.assoc, rL_bc_def)

rewrite rL_ac_comm :
  rL * id * id ; id * sw * id ; a * c
  = id * sw * id ; a * c ; rL_ac by simp(H.rL_unfold, A.assoc, C.assoc, rL_ac_def)

# From this, it is enough to show that acting on A (X) B (X) C by the Yang-Baxtor state defined in 'quasi_tri' yields the LHS
# and RHS of the module version of the Yang-Baxter equation:

rewrite yb_mod_lem1 :
  H.yb1 * sw[2, 1, 0] ; sw[0, 3, 1, 4, 2, 5]; a * b * c
  = sw * id ; rL_bc * id ; id * sw ; id * rL_ac ; sw * id ; rL_ab * id by simp(H.yb1_def, rL_ab_comm, rL_bc_comm, rL_ac_comm, A.unit, B.unit, C.unit)

rewrite yb_mod_lem2 :
  H.yb2 * sw[2, 1, 0] ; sw[0, 3, 1, 4, 2, 5]; a * b * c
  = id * sw ; id * rL_ab ; sw * id ; rL_ac * id ; id * sw ; id * rL_bc by simp(H.yb2_def, rL_ab_comm, rL_bc_comm, rL_ac_comm, A.unit, B.unit, C.unit)

# Putting these together shows us that the br_XX maps indeed satisfy the Yang-Baxter equation
rewrite yang_baxter_mod :
  id * br_ab ; br_ac * id ; id * br_bc
  = sw[2, 1, 0] ; H.yb2 * id * id * id ; id * sw[2, 0, 3, 1] * id ; a * b * c by -yb_mod_lem2
  = sw[2, 1, 0] ; H.yb1 * id * id * id ; id * sw[2, 0, 3, 1] * id ; a * b * c by -H.yang_baxter_state
  = sw * id ; rL_bc * id ; id * sw ; id * rL_ac ; sw * id ; rL_ab * id by yb_mod_lem1
  = br_bc * id ; id * br_ac ; br_ab * id

show yang_baxter_mod

